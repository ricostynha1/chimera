// This program was cloned from: https://github.com/zhangmozhe/microshift_compression
// License: Apache License 2.0

// -------------------------------------------------------------
// 
// File Name: C:\Users\Bo\OneDrive - HKUST Connect\Bit depth compression\FPGA Implementation\Final\temp\codegen\compression_hdl_lowpower\hdlsrc\compression_hdl_lowpower_tb.v
// Created: 2018-07-17 11:59:52
// 
// Generated by MATLAB 9.1, MATLAB Coder 3.2 and HDL Coder 3.9
// 
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ceout         1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// bitstreamready                ceout         1
// bitstreamlengt                ceout         1
// subimageindexo                ceout         1
// bitstreamoutpu                ceout         1
// hstartoutput                  ceout         1
// hendoutput                    ceout         1
// vstartoutput                  ceout         1
// vendoutput                    ceout         1
// validoutput                   ceout         1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: compression_hdl_lowpower_tb
// Source Path: 
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module compression_hdl_lowpower_tb
          (
           
          );




  reg  clk;
  reg  resetx;
  wire enb;
  wire validoutput_done;  // ufix1
  wire rdEnb;
  wire validoutput_done_enb;  // ufix1
  reg [15:0] bitstreamready_addr;  // ufix16
  wire validoutput_lastAddr;  // ufix1
  reg  check9_done;  // ufix1
  wire vendoutput_done;  // ufix1
  wire vendoutput_done_enb;  // ufix1
  wire vendoutput_lastAddr;  // ufix1
  reg  check8_done;  // ufix1
  wire vstartoutput_done;  // ufix1
  wire vstartoutput_done_enb;  // ufix1
  wire vstartoutput_lastAddr;  // ufix1
  reg  check7_done;  // ufix1
  wire hendoutput_done;  // ufix1
  wire hendoutput_done_enb;  // ufix1
  wire hendoutput_lastAddr;  // ufix1
  reg  check6_done;  // ufix1
  wire hstartoutput_done;  // ufix1
  wire hstartoutput_done_enb;  // ufix1
  wire hstartoutput_lastAddr;  // ufix1
  reg  check5_done;  // ufix1
  wire bitstreamoutpu_done;  // ufix1
  wire bitstreamoutpu_done_enb;  // ufix1
  wire bitstreamoutpu_lastAddr;  // ufix1
  reg  check4_done;  // ufix1
  wire subimageindexo_done;  // ufix1
  wire subimageindexo_done_enb;  // ufix1
  wire subimageindexo_lastAddr;  // ufix1
  reg  check3_done;  // ufix1
  wire bitstreamlengt_done;  // ufix1
  wire bitstreamlengt_done_enb;  // ufix1
  wire bitstreamlengt_lastAddr;  // ufix1
  reg  check2_done;  // ufix1
  wire bitstreamready_done;  // ufix1
  wire bitstreamready_done_enb;  // ufix1
  wire bitstreamready_active;  // ufix1
  wire [15:0] validoutput_addr_delay_1;  // ufix16
  wire [15:0] vendoutput_addr_delay_1;  // ufix16
  wire [15:0] vstartoutput_addr_delay_1;  // ufix16
  wire [15:0] hendoutput_addr_delay_1;  // ufix16
  wire [15:0] hstartoutput_addr_delay_1;  // ufix16
  wire [15:0] bitstreamoutpu_addr_delay_1;  // ufix16
  wire [15:0] subimageindexo_addr_delay_1;  // ufix16
  wire [15:0] bitstreamlengt_addr_delay_1;  // ufix16
  wire [15:0] bitstreamready_addr_delay_1;  // ufix16
  reg [15:0] pixelIn_addr;  // ufix16
  wire [15:0] mode_addr_delay_1;  // ufix16
  wire [15:0] valid_addr_delay_1;  // ufix16
  wire [15:0] vEnd_addr_delay_1;  // ufix16
  wire [15:0] vStart_addr_delay_1;  // ufix16
  wire [15:0] hEnd_addr_delay_1;  // ufix16
  wire [15:0] hStart_addr_delay_1;  // ufix16
  wire pixelIn_active;  // ufix1
  wire tb_enb;
  wire pixelIn_enb;  // ufix1
  wire [15:0] pixelIn_addr_delay_1;  // ufix16
  wire ceout;
  wire [7:0] pixelin_1;  // uint8
  wire hstart;
  wire hend;
  wire vstart;
  wire vend;
  wire valid;
  wire [1:0] mode;  // ufix2
  wire bitstreamready_ref;
  wire [3:0] bitstreamlengt_ref;  // ufix4
  wire [3:0] subimageindexo_ref;  // ufix4
  wire [9:0] bitstreamoutpu_ref;  // ufix10
  wire hstartoutput_ref;
  wire hendoutput_ref;
  wire vstartoutput_ref;
  wire vendoutput_ref;
  wire validoutput_ref;
  wire snkDone;
  wire snkDonen;
  wire bitstreamready;
  wire [3:0] bitstreamlengt;  // ufix4
  wire [3:0] subimageindexo;  // ufix4
  wire [9:0] bitstreamoutpu;  // ufix10
  wire hstartoutput;
  wire hendoutput;
  wire vstartoutput;
  wire vendoutput;
  wire validoutput;
  wire bitstreamready_enb;  // ufix1
  wire bitstreamready_lastAddr;  // ufix1
  reg  check1_done;  // ufix1
  reg [2:0] bitstreamready_chkcnt;  // ufix3
  wire bitstreamready_ignCntDone;  // ufix1
  wire bitstreamready_needToCount;  // ufix1
  wire bitstreamready_chkenb;  // ufix1
  wire bitstreamready_chkdata;  // ufix1
  reg  bitstreamready_testFailure;  // ufix1
  reg [2:0] bitstreamlengt_chkcnt;  // ufix3
  wire bitstreamlengt_ignCntDone;  // ufix1
  wire bitstreamlengt_needToCount;  // ufix1
  wire bitstreamlengt_chkenb;  // ufix1
  wire bitstreamlengt_chkdata;  // ufix1
  reg  bitstreamlengt_testFailure;  // ufix1
  reg [2:0] subimageindexo_chkcnt;  // ufix3
  wire subimageindexo_ignCntDone;  // ufix1
  wire subimageindexo_needToCount;  // ufix1
  wire subimageindexo_chkenb;  // ufix1
  wire subimageindexo_chkdata;  // ufix1
  reg  subimageindexo_testFailure;  // ufix1
  reg [2:0] bitstreamoutpu_chkcnt;  // ufix3
  wire bitstreamoutpu_ignCntDone;  // ufix1
  wire bitstreamoutpu_needToCount;  // ufix1
  wire bitstreamoutpu_chkenb;  // ufix1
  wire bitstreamoutpu_chkdata;  // ufix1
  reg  bitstreamoutpu_testFailure;  // ufix1
  reg [2:0] hstartoutput_chkcnt;  // ufix3
  wire hstartoutput_ignCntDone;  // ufix1
  wire hstartoutput_needToCount;  // ufix1
  wire hstartoutput_chkenb;  // ufix1
  wire hstartoutput_chkdata;  // ufix1
  reg  hstartoutput_testFailure;  // ufix1
  reg [2:0] hendoutput_chkcnt;  // ufix3
  wire hendoutput_ignCntDone;  // ufix1
  wire hendoutput_needToCount;  // ufix1
  wire hendoutput_chkenb;  // ufix1
  wire hendoutput_chkdata;  // ufix1
  reg  hendoutput_testFailure;  // ufix1
  reg [2:0] vstartoutput_chkcnt;  // ufix3
  wire vstartoutput_ignCntDone;  // ufix1
  wire vstartoutput_needToCount;  // ufix1
  wire vstartoutput_chkenb;  // ufix1
  wire vstartoutput_chkdata;  // ufix1
  reg  vstartoutput_testFailure;  // ufix1
  reg [2:0] vendoutput_chkcnt;  // ufix3
  wire vendoutput_ignCntDone;  // ufix1
  wire vendoutput_needToCount;  // ufix1
  wire vendoutput_chkenb;  // ufix1
  wire vendoutput_chkdata;  // ufix1
  reg  vendoutput_testFailure;  // ufix1
  reg [2:0] validoutput_chkcnt;  // ufix3
  wire validoutput_ignCntDone;  // ufix1
  wire validoutput_needToCount;  // ufix1
  wire validoutput_chkenb;  // ufix1
  wire validoutput_chkdata;  // ufix1
  reg  validoutput_testFailure;  // ufix1
  wire testFailure;  // ufix1


  assign validoutput_done_enb = validoutput_done & rdEnb;



  assign validoutput_lastAddr = bitstreamready_addr >= 16'b1111000010100000;



  assign validoutput_done = validoutput_lastAddr & resetx;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or negedge resetx)
    begin : checkDone_9
      if (!resetx) begin
        check9_done <= 0;
      end
      else begin
        if (validoutput_done_enb) begin
          check9_done <= validoutput_done;
        end
      end
    end

  assign vendoutput_done_enb = vendoutput_done & rdEnb;



  assign vendoutput_lastAddr = bitstreamready_addr >= 16'b1111000010100000;



  assign vendoutput_done = vendoutput_lastAddr & resetx;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or negedge resetx)
    begin : checkDone_8
      if (!resetx) begin
        check8_done <= 0;
      end
      else begin
        if (vendoutput_done_enb) begin
          check8_done <= vendoutput_done;
        end
      end
    end

  assign vstartoutput_done_enb = vstartoutput_done & rdEnb;



  assign vstartoutput_lastAddr = bitstreamready_addr >= 16'b1111000010100000;



  assign vstartoutput_done = vstartoutput_lastAddr & resetx;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or negedge resetx)
    begin : checkDone_7
      if (!resetx) begin
        check7_done <= 0;
      end
      else begin
        if (vstartoutput_done_enb) begin
          check7_done <= vstartoutput_done;
        end
      end
    end

  assign hendoutput_done_enb = hendoutput_done & rdEnb;



  assign hendoutput_lastAddr = bitstreamready_addr >= 16'b1111000010100000;



  assign hendoutput_done = hendoutput_lastAddr & resetx;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or negedge resetx)
    begin : checkDone_6
      if (!resetx) begin
        check6_done <= 0;
      end
      else begin
        if (hendoutput_done_enb) begin
          check6_done <= hendoutput_done;
        end
      end
    end

  assign hstartoutput_done_enb = hstartoutput_done & rdEnb;



  assign hstartoutput_lastAddr = bitstreamready_addr >= 16'b1111000010100000;



  assign hstartoutput_done = hstartoutput_lastAddr & resetx;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or negedge resetx)
    begin : checkDone_5
      if (!resetx) begin
        check5_done <= 0;
      end
      else begin
        if (hstartoutput_done_enb) begin
          check5_done <= hstartoutput_done;
        end
      end
    end

  assign bitstreamoutpu_done_enb = bitstreamoutpu_done & rdEnb;



  assign bitstreamoutpu_lastAddr = bitstreamready_addr >= 16'b1111000010100000;



  assign bitstreamoutpu_done = bitstreamoutpu_lastAddr & resetx;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or negedge resetx)
    begin : checkDone_4
      if (!resetx) begin
        check4_done <= 0;
      end
      else begin
        if (bitstreamoutpu_done_enb) begin
          check4_done <= bitstreamoutpu_done;
        end
      end
    end

  assign subimageindexo_done_enb = subimageindexo_done & rdEnb;



  assign subimageindexo_lastAddr = bitstreamready_addr >= 16'b1111000010100000;



  assign subimageindexo_done = subimageindexo_lastAddr & resetx;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or negedge resetx)
    begin : checkDone_3
      if (!resetx) begin
        check3_done <= 0;
      end
      else begin
        if (subimageindexo_done_enb) begin
          check3_done <= subimageindexo_done;
        end
      end
    end

  assign bitstreamlengt_done_enb = bitstreamlengt_done & rdEnb;



  assign bitstreamlengt_lastAddr = bitstreamready_addr >= 16'b1111000010100000;



  assign bitstreamlengt_done = bitstreamlengt_lastAddr & resetx;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or negedge resetx)
    begin : checkDone_2
      if (!resetx) begin
        check2_done <= 0;
      end
      else begin
        if (bitstreamlengt_done_enb) begin
          check2_done <= bitstreamlengt_done;
        end
      end
    end

  assign bitstreamready_done_enb = bitstreamready_done & rdEnb;



  assign bitstreamready_active = bitstreamready_addr != 16'b1111000010100000;



  assign #1 validoutput_addr_delay_1 = bitstreamready_addr;

  assign #1 vendoutput_addr_delay_1 = bitstreamready_addr;

  assign #1 vstartoutput_addr_delay_1 = bitstreamready_addr;

  assign #1 hendoutput_addr_delay_1 = bitstreamready_addr;

  assign #1 hstartoutput_addr_delay_1 = bitstreamready_addr;

  assign #1 bitstreamoutpu_addr_delay_1 = bitstreamready_addr;

  assign #1 subimageindexo_addr_delay_1 = bitstreamready_addr;

  assign #1 bitstreamlengt_addr_delay_1 = bitstreamready_addr;

  assign #1 bitstreamready_addr_delay_1 = bitstreamready_addr;

  assign #1 mode_addr_delay_1 = pixelIn_addr;

  assign #1 valid_addr_delay_1 = pixelIn_addr;

  assign #1 vEnd_addr_delay_1 = pixelIn_addr;

  assign #1 vStart_addr_delay_1 = pixelIn_addr;

  assign #1 hEnd_addr_delay_1 = pixelIn_addr;

  assign #1 hStart_addr_delay_1 = pixelIn_addr;

  assign pixelIn_active = pixelIn_addr != 16'b1111000011001000;



  assign pixelIn_enb = pixelIn_active & (rdEnb & tb_enb);



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 61640
  always @(posedge clk or negedge resetx)
    begin : pixelIn_process
      if (resetx == 1'b0) begin
        pixelIn_addr <= 16'b0000000000000000;
      end
      else begin
        if (pixelIn_enb) begin
          if (pixelIn_addr == 16'b1111000011001000) begin
            pixelIn_addr <= 16'b0000000000000000;
          end
          else begin
            pixelIn_addr <= pixelIn_addr + 16'b0000000000000001;
          end
        end
      end
    end



  assign #1 pixelIn_addr_delay_1 = pixelIn_addr;

  compression_hdl_lowpower_tb_data   u_compression_hdl_lowpower_tb_data   (.clk(clk),
                                                                           .resetx(resetx),
                                                                           .pixelIn_addr(pixelIn_addr_delay_1),  // ufix16
                                                                           .hStart_addr(hStart_addr_delay_1),  // ufix16
                                                                           .hEnd_addr(hEnd_addr_delay_1),  // ufix16
                                                                           .vStart_addr(vStart_addr_delay_1),  // ufix16
                                                                           .vEnd_addr(vEnd_addr_delay_1),  // ufix16
                                                                           .valid_addr(valid_addr_delay_1),  // ufix16
                                                                           .mode_addr(mode_addr_delay_1),  // ufix16
                                                                           .bitstreamready_addr(bitstreamready_addr_delay_1),  // ufix16
                                                                           .bitstreamlengt_addr(bitstreamlengt_addr_delay_1),  // ufix16
                                                                           .subimageindexo_addr(subimageindexo_addr_delay_1),  // ufix16
                                                                           .bitstreamoutpu_addr(bitstreamoutpu_addr_delay_1),  // ufix16
                                                                           .hstartoutput_addr(hstartoutput_addr_delay_1),  // ufix16
                                                                           .hendoutput_addr(hendoutput_addr_delay_1),  // ufix16
                                                                           .vstartoutput_addr(vstartoutput_addr_delay_1),  // ufix16
                                                                           .vendoutput_addr(vendoutput_addr_delay_1),  // ufix16
                                                                           .validoutput_addr(validoutput_addr_delay_1),  // ufix16
                                                                           .tb_enb_delay(tb_enb),
                                                                           .rdEnb(rdEnb),
                                                                           .ceout(ceout),
                                                                           .pixelin(pixelin_1),  // uint8
                                                                           .hstart(hstart),
                                                                           .hend(hend),
                                                                           .vstart(vstart),
                                                                           .vend(vend),
                                                                           .valid(valid),
                                                                           .mode(mode),  // ufix2
                                                                           .bitstreamready_expected(bitstreamready_ref),
                                                                           .bitstreamlengt_expected(bitstreamlengt_ref),  // ufix4
                                                                           .subimageindexo_expected(subimageindexo_ref),  // ufix4
                                                                           .bitstreamoutpu_expected(bitstreamoutpu_ref),  // ufix10
                                                                           .hstartoutput_expected(hstartoutput_ref),
                                                                           .hendoutput_expected(hendoutput_ref),
                                                                           .vstartoutput_expected(vstartoutput_ref),
                                                                           .vendoutput_expected(vendoutput_ref),
                                                                           .validoutput_expected(validoutput_ref)
                                                                           );

  assign snkDonen =  ~ snkDone;



  assign tb_enb = resetx & snkDonen;



  assign rdEnb = (snkDone == 1'b0 ? tb_enb :
              1'b0);



  assign #2 enb = rdEnb;

  initial
    begin : resetx_gen
      resetx <= 1'b0;
      # (200);
      @ (posedge clk)
      # (2);
      resetx <= 1'b1;
    end

  always 
    begin : clk_gen
      clk <= 1'b1;
      # (50);
      clk <= 1'b0;
      # (50);
      if (snkDone == 1'b1) begin
        clk <= 1'b1;
        # (50);
        clk <= 1'b0;
        # (50);
        $finish;
      end
    end

  compression_hdl_lowpower   u_compression_hdl_lowpower   (.clk(clk),
                                                           .resetx(resetx),
                                                           .clkenable(enb),
                                                           .pixelin(pixelin_1),  // uint8
                                                           .hstart(hstart),
                                                           .hend(hend),
                                                           .vstart(vstart),
                                                           .vend(vend),
                                                           .valid(valid),
                                                           .mode(mode),  // ufix2
                                                           .ceout(ceout),
                                                           .bitstreamready(bitstreamready),
                                                           .bitstreamlengt(bitstreamlengt),  // ufix4
                                                           .subimageindexo(subimageindexo),  // ufix4
                                                           .bitstreamoutpu(bitstreamoutpu),  // ufix10
                                                           .hstartoutput(hstartoutput),
                                                           .hendoutput(hendoutput),
                                                           .vstartoutput(vstartoutput),
                                                           .vendoutput(vendoutput),
                                                           .validoutput(validoutput)
                                                           );

  assign bitstreamready_enb = ceout & bitstreamready_active;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 61600
  always @(posedge clk or negedge resetx)
    begin : bitstream_ready_process
      if (resetx == 1'b0) begin
        bitstreamready_addr <= 16'b0000000000000000;
      end
      else begin
        if (bitstreamready_enb) begin
          if (bitstreamready_addr == 16'b1111000010100000) begin
            bitstreamready_addr <= 16'b0000000000000000;
          end
          else begin
            bitstreamready_addr <= bitstreamready_addr + 16'b0000000000000001;
          end
        end
      end
    end



  assign bitstreamready_lastAddr = bitstreamready_addr >= 16'b1111000010100000;



  assign bitstreamready_done = bitstreamready_lastAddr & resetx;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or negedge resetx)
    begin : checkDone_1
      if (!resetx) begin
        check1_done <= 0;
      end
      else begin
        if (bitstreamready_done_enb) begin
          check1_done <= bitstreamready_done;
        end
      end
    end

  assign snkDone = check9_done & (check8_done & (check7_done & (check6_done & (check5_done & (check4_done & (check3_done & (check1_done & check2_done)))))));



  assign bitstreamready_ignCntDone = bitstreamready_chkcnt != 3'b101;



  assign bitstreamready_needToCount = ceout & bitstreamready_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  always @(posedge clk or negedge resetx)
    begin : bitstreamready_IgnoreDataChecking_process
      if (resetx == 1'b0) begin
        bitstreamready_chkcnt <= 3'b000;
      end
      else begin
        if (bitstreamready_needToCount) begin
          if (bitstreamready_chkcnt == 3'b101) begin
            bitstreamready_chkcnt <= 3'b000;
          end
          else begin
            bitstreamready_chkcnt <= bitstreamready_chkcnt + 3'b001;
          end
        end
      end
    end



  assign bitstreamready_chkenb = bitstreamready_chkcnt == 3'b101;



  assign bitstreamready_chkdata = ceout & bitstreamready_chkenb;



  always @(posedge clk or negedge resetx)
    begin : bitstreamready_checker
      if (resetx == 1'b0) begin
        bitstreamready_testFailure <= 1'b0;
      end
      else begin
        if (bitstreamready_chkdata == 1'b1 && bitstreamready !== bitstreamready_ref) begin
          bitstreamready_testFailure <= 1'b1;
          $display("ERROR in bitstreamready at time %t : Expected '%h' Actual '%h'", $time, bitstreamready_ref, bitstreamready);
        end
      end
    end

  assign bitstreamlengt_ignCntDone = bitstreamlengt_chkcnt != 3'b101;



  assign bitstreamlengt_needToCount = ceout & bitstreamlengt_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  always @(posedge clk or negedge resetx)
    begin : bitstreamlengt_IgnoreDataChecking_process
      if (resetx == 1'b0) begin
        bitstreamlengt_chkcnt <= 3'b000;
      end
      else begin
        if (bitstreamlengt_needToCount) begin
          if (bitstreamlengt_chkcnt == 3'b101) begin
            bitstreamlengt_chkcnt <= 3'b000;
          end
          else begin
            bitstreamlengt_chkcnt <= bitstreamlengt_chkcnt + 3'b001;
          end
        end
      end
    end



  assign bitstreamlengt_chkenb = bitstreamlengt_chkcnt == 3'b101;



  assign bitstreamlengt_chkdata = ceout & bitstreamlengt_chkenb;



  always @(posedge clk or negedge resetx)
    begin : bitstreamlengt_checker
      if (resetx == 1'b0) begin
        bitstreamlengt_testFailure <= 1'b0;
      end
      else begin
        if (bitstreamlengt_chkdata == 1'b1 && bitstreamlengt !== bitstreamlengt_ref) begin
          bitstreamlengt_testFailure <= 1'b1;
          $display("ERROR in bitstreamlengt at time %t : Expected '%h' Actual '%h'", $time, bitstreamlengt_ref, bitstreamlengt);
        end
      end
    end

  assign subimageindexo_ignCntDone = subimageindexo_chkcnt != 3'b101;



  assign subimageindexo_needToCount = ceout & subimageindexo_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  always @(posedge clk or negedge resetx)
    begin : subimageindexo_IgnoreDataChecking_process
      if (resetx == 1'b0) begin
        subimageindexo_chkcnt <= 3'b000;
      end
      else begin
        if (subimageindexo_needToCount) begin
          if (subimageindexo_chkcnt == 3'b101) begin
            subimageindexo_chkcnt <= 3'b000;
          end
          else begin
            subimageindexo_chkcnt <= subimageindexo_chkcnt + 3'b001;
          end
        end
      end
    end



  assign subimageindexo_chkenb = subimageindexo_chkcnt == 3'b101;



  assign subimageindexo_chkdata = ceout & subimageindexo_chkenb;



  always @(posedge clk or negedge resetx)
    begin : subimageindexo_checker
      if (resetx == 1'b0) begin
        subimageindexo_testFailure <= 1'b0;
      end
      else begin
        if (subimageindexo_chkdata == 1'b1 && subimageindexo !== subimageindexo_ref) begin
          subimageindexo_testFailure <= 1'b1;
          $display("ERROR in subimageindexo at time %t : Expected '%h' Actual '%h'", $time, subimageindexo_ref, subimageindexo);
        end
      end
    end

  assign bitstreamoutpu_ignCntDone = bitstreamoutpu_chkcnt != 3'b101;



  assign bitstreamoutpu_needToCount = ceout & bitstreamoutpu_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  always @(posedge clk or negedge resetx)
    begin : bitstreamoutpu_IgnoreDataChecking_process
      if (resetx == 1'b0) begin
        bitstreamoutpu_chkcnt <= 3'b000;
      end
      else begin
        if (bitstreamoutpu_needToCount) begin
          if (bitstreamoutpu_chkcnt == 3'b101) begin
            bitstreamoutpu_chkcnt <= 3'b000;
          end
          else begin
            bitstreamoutpu_chkcnt <= bitstreamoutpu_chkcnt + 3'b001;
          end
        end
      end
    end



  assign bitstreamoutpu_chkenb = bitstreamoutpu_chkcnt == 3'b101;



  assign bitstreamoutpu_chkdata = ceout & bitstreamoutpu_chkenb;



  always @(posedge clk or negedge resetx)
    begin : bitstreamoutpu_checker
      if (resetx == 1'b0) begin
        bitstreamoutpu_testFailure <= 1'b0;
      end
      else begin
        if (bitstreamoutpu_chkdata == 1'b1 && bitstreamoutpu !== bitstreamoutpu_ref) begin
          bitstreamoutpu_testFailure <= 1'b1;
          $display("ERROR in bitstreamoutpu at time %t : Expected '%h' Actual '%h'", $time, bitstreamoutpu_ref, bitstreamoutpu);
        end
      end
    end

  assign hstartoutput_ignCntDone = hstartoutput_chkcnt != 3'b101;



  assign hstartoutput_needToCount = ceout & hstartoutput_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  always @(posedge clk or negedge resetx)
    begin : hstartoutput_IgnoreDataChecking_process
      if (resetx == 1'b0) begin
        hstartoutput_chkcnt <= 3'b000;
      end
      else begin
        if (hstartoutput_needToCount) begin
          if (hstartoutput_chkcnt == 3'b101) begin
            hstartoutput_chkcnt <= 3'b000;
          end
          else begin
            hstartoutput_chkcnt <= hstartoutput_chkcnt + 3'b001;
          end
        end
      end
    end



  assign hstartoutput_chkenb = hstartoutput_chkcnt == 3'b101;



  assign hstartoutput_chkdata = ceout & hstartoutput_chkenb;



  always @(posedge clk or negedge resetx)
    begin : hstartoutput_checker
      if (resetx == 1'b0) begin
        hstartoutput_testFailure <= 1'b0;
      end
      else begin
        if (hstartoutput_chkdata == 1'b1 && hstartoutput !== hstartoutput_ref) begin
          hstartoutput_testFailure <= 1'b1;
          $display("ERROR in hstartoutput at time %t : Expected '%h' Actual '%h'", $time, hstartoutput_ref, hstartoutput);
        end
      end
    end

  assign hendoutput_ignCntDone = hendoutput_chkcnt != 3'b101;



  assign hendoutput_needToCount = ceout & hendoutput_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  always @(posedge clk or negedge resetx)
    begin : hendoutput_IgnoreDataChecking_process
      if (resetx == 1'b0) begin
        hendoutput_chkcnt <= 3'b000;
      end
      else begin
        if (hendoutput_needToCount) begin
          if (hendoutput_chkcnt == 3'b101) begin
            hendoutput_chkcnt <= 3'b000;
          end
          else begin
            hendoutput_chkcnt <= hendoutput_chkcnt + 3'b001;
          end
        end
      end
    end



  assign hendoutput_chkenb = hendoutput_chkcnt == 3'b101;



  assign hendoutput_chkdata = ceout & hendoutput_chkenb;



  always @(posedge clk or negedge resetx)
    begin : hendoutput_checker
      if (resetx == 1'b0) begin
        hendoutput_testFailure <= 1'b0;
      end
      else begin
        if (hendoutput_chkdata == 1'b1 && hendoutput !== hendoutput_ref) begin
          hendoutput_testFailure <= 1'b1;
          $display("ERROR in hendoutput at time %t : Expected '%h' Actual '%h'", $time, hendoutput_ref, hendoutput);
        end
      end
    end

  assign vstartoutput_ignCntDone = vstartoutput_chkcnt != 3'b101;



  assign vstartoutput_needToCount = ceout & vstartoutput_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  always @(posedge clk or negedge resetx)
    begin : vstartoutput_IgnoreDataChecking_process
      if (resetx == 1'b0) begin
        vstartoutput_chkcnt <= 3'b000;
      end
      else begin
        if (vstartoutput_needToCount) begin
          if (vstartoutput_chkcnt == 3'b101) begin
            vstartoutput_chkcnt <= 3'b000;
          end
          else begin
            vstartoutput_chkcnt <= vstartoutput_chkcnt + 3'b001;
          end
        end
      end
    end



  assign vstartoutput_chkenb = vstartoutput_chkcnt == 3'b101;



  assign vstartoutput_chkdata = ceout & vstartoutput_chkenb;



  always @(posedge clk or negedge resetx)
    begin : vstartoutput_checker
      if (resetx == 1'b0) begin
        vstartoutput_testFailure <= 1'b0;
      end
      else begin
        if (vstartoutput_chkdata == 1'b1 && vstartoutput !== vstartoutput_ref) begin
          vstartoutput_testFailure <= 1'b1;
          $display("ERROR in vstartoutput at time %t : Expected '%h' Actual '%h'", $time, vstartoutput_ref, vstartoutput);
        end
      end
    end

  assign vendoutput_ignCntDone = vendoutput_chkcnt != 3'b101;



  assign vendoutput_needToCount = ceout & vendoutput_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  always @(posedge clk or negedge resetx)
    begin : vendoutput_IgnoreDataChecking_process
      if (resetx == 1'b0) begin
        vendoutput_chkcnt <= 3'b000;
      end
      else begin
        if (vendoutput_needToCount) begin
          if (vendoutput_chkcnt == 3'b101) begin
            vendoutput_chkcnt <= 3'b000;
          end
          else begin
            vendoutput_chkcnt <= vendoutput_chkcnt + 3'b001;
          end
        end
      end
    end



  assign vendoutput_chkenb = vendoutput_chkcnt == 3'b101;



  assign vendoutput_chkdata = ceout & vendoutput_chkenb;



  always @(posedge clk or negedge resetx)
    begin : vendoutput_checker
      if (resetx == 1'b0) begin
        vendoutput_testFailure <= 1'b0;
      end
      else begin
        if (vendoutput_chkdata == 1'b1 && vendoutput !== vendoutput_ref) begin
          vendoutput_testFailure <= 1'b1;
          $display("ERROR in vendoutput at time %t : Expected '%h' Actual '%h'", $time, vendoutput_ref, vendoutput);
        end
      end
    end

  assign validoutput_ignCntDone = validoutput_chkcnt != 3'b101;



  assign validoutput_needToCount = ceout & validoutput_ignCntDone;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 5
  always @(posedge clk or negedge resetx)
    begin : validoutput_IgnoreDataChecking_process
      if (resetx == 1'b0) begin
        validoutput_chkcnt <= 3'b000;
      end
      else begin
        if (validoutput_needToCount) begin
          if (validoutput_chkcnt == 3'b101) begin
            validoutput_chkcnt <= 3'b000;
          end
          else begin
            validoutput_chkcnt <= validoutput_chkcnt + 3'b001;
          end
        end
      end
    end



  assign validoutput_chkenb = validoutput_chkcnt == 3'b101;



  assign validoutput_chkdata = ceout & validoutput_chkenb;



  always @(posedge clk or negedge resetx)
    begin : validoutput_checker
      if (resetx == 1'b0) begin
        validoutput_testFailure <= 1'b0;
      end
      else begin
        if (validoutput_chkdata == 1'b1 && validoutput !== validoutput_ref) begin
          validoutput_testFailure <= 1'b1;
          $display("ERROR in validoutput at time %t : Expected '%h' Actual '%h'", $time, validoutput_ref, validoutput);
        end
      end
    end

  assign testFailure = validoutput_testFailure | (vendoutput_testFailure | (vstartoutput_testFailure | (hendoutput_testFailure | (hstartoutput_testFailure | (bitstreamoutpu_testFailure | (subimageindexo_testFailure | (bitstreamready_testFailure | bitstreamlengt_testFailure)))))));



  always @(posedge clk)
    begin : completed_msg
      if (snkDone == 1'b1) begin
        if (testFailure == 1'b0) begin
          $display("**************TEST COMPLETED (PASSED)**************");
        end
        else begin
          $display("**************TEST COMPLETED (FAILED)**************");
        end
      end
    end

endmodule  // compression_hdl_lowpower_tb

